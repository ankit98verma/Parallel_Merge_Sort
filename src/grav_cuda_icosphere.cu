/*
 * CUDA blur
 */
#ifndef _GRAV_CUDA_ICOSPHERE_CU_
	#define _GRAV_CUDA_ICOSPHERE_CU_
#endif

#include <math.h>

#include "grav_cuda.cuh"
#include <curand.h>


/* Local variables */

float * pointers_sums[2];		// stores the index of the pointers_sums which points to the most updated sums array
int ind2_sums;					// the pointer to contain the address of the sums array
float * dev_face_sums;			// it contains the sums of components of each vertex in the device memory (GPU memory)
float * dev_face_sums_cpy;		// a copy for the sums of components of each vertex in the device memory (GPU memory)


/* Local functions */
__device__ void get_first_greatest(float * arr, int len, float a, int * res_fg);
__device__ void get_last_smallest(float * arr, int len, float a, int * res_ls);

/*******************************************************************************
 * Function:        cuda_cpy_input_data
 *
 * Description:     This function allocate the memory for various array in the GPU
 *					memory. It also allocates the memory for gpu_out_vertices and 
 *					gpu_out_faces in the CPU memory. It copies the initial icosphere 
 *					data to the dev_faces array in the device.
 *
 * Arguments:       None
 *
 * Return Values:   None
*******************************************************************************/
void cuda_cpy_input_data(){

	CUDA_CALL(cudaMalloc((void **)&dev_face_sums, 3*faces_length * sizeof(float)));
	CUDA_CALL(cudaMalloc((void**) &dev_face_sums_cpy, 3*faces_length* sizeof(float)));


	
	// set the sum pointers
	pointers_sums[0] = dev_face_sums;	
	pointers_sums[1] = dev_face_sums_cpy;
	ind2_sums = 0;						// set the index denoting the latest sum of components of vertices array to 0

	gpu_out_sums = (float *)malloc(3*faces_length*sizeof(float));


	curandGenerator_t gen;
	/* Create pseudo-random number generator */
   	curandCreateGenerator(&gen, 
                CURAND_RNG_PSEUDO_DEFAULT);
    
    /* Set seed */
    curandSetPseudoRandomGeneratorSeed(gen, 
                1232);

    /* Generate n floats on device */
    curandGenerateUniform(gen, dev_face_sums, 3*faces_length*sizeof(float));
    curandDestroyGenerator(gen);
}

/*******************************************************************************
 * Function:        cuda_cpy_output_data
 *
 * Description:     This function copies the latest faces array to the CPU memory.
 *					It also copies the vertices generated by the GPU to the CPU 
 *					memory.
 *
 * Arguments:       None
 *
 * Return Values:   None
*******************************************************************************/
void cuda_cpy_output_data(){
	CUDA_CALL(cudaMemcpy(gpu_out_sums, pointers_sums[ind2_sums], 3*faces_length*sizeof(float), cudaMemcpyDeviceToHost));
	
}

/*******************************************************************************
 * Function:        free_gpu_memory
 *
 * Description:     This function frees the GPU memory and the corresponding GPU
 *					output memory in the CPU.
 *
 * Arguments:       None
 *
 * Return Values:   None
*******************************************************************************/
void free_gpu_memory(){
	
	CUDA_CALL(cudaFree(dev_face_sums));
	CUDA_CALL(cudaFree(dev_face_sums_cpy));


	free(gpu_out_sums);
}


/*******************************************************************************
 * Function:        dev_merge
 *
 * Description:     This function SEQUENTIALLY merges two already sorted arrays into
 * 					a single sorted array. The two arrays here are:
 *
 * 					s[idx] and s[start]. Let us say arr1 denotes s[idx] array and
 * 					arr2 denotes s[start] array.
 *
 * 					The size of arr1 = start - idx
 * 					The size of arr2 = end - start
 *
 * 					Following is the reference to the merging of sorted arrays into
 * 					one sorted array:
 * 					https://www.geeksforgeeks.org/merge-two-sorted-arrays/
 *
 * 					The arr1 and arr2 is sorted and the result is put into the 
 * 					array "r".
 *
 * 					Note that the array "ind[start]" and "ind[idx]" is also sorted but
 * 					with respect to the "s[idx]" and "s[start]" array. That is the values
 * 					of "s[idx]" and "s[start]" are used for comparison and "ind[idx]" and
 * 					"ind[start]" are sorted accordingly.
 *
 * Arguments:       float * s: The array of sums of vertices
 * 					float * r: The array to which the sorted sums array will be stored
 * 					int * ind: The array of indices of vertices
 * 					int * ind_res: The array to which the sorted indices array will be saved.
 *					unsigned int idx: The start of first array
 *					unsigned int start: The start of second array
 *					unsinged int end: The end of second array
 *
 * Return Values:   None
*******************************************************************************/
__device__
void dev_merge(float * s, float * r, unsigned int idx, unsigned int start, unsigned int end){
	unsigned int c=idx;
	unsigned int i=idx;unsigned int j=start;
	while(j<end && i<start){
		if(s[i] <= s[j]){
			r[c] = s[i];
			i++;
		}
		else{
			r[c] = s[j];
			j++;
		}
		c++;
	}
	while(i < start){
		r[c] = s[i];
		c++;i++;
	}

	while(j < end){
		r[c] = s[j];
		c++;j++;
	}
}

/*******************************************************************************
 * Function:        kernel_merge_sort
 *
 * Description:     This is a naive kernal which implements the a step of merge sorting. The
 * 					input "r" represents the total length of the two arrays. For 
 * 					example consider the following example:
 *
 * 					sums[] = {4, 3, 2, 1, 0};
 *
 * 					We have ceil(log2(length(sums))) = 3, hence the kernel has to 
 * 					be called 3 times for ith time (starting i=0) the value of
 * 					"r" should be 2^(i+1).
 *
 * 					So when kernel is called:
 * 					For r = 2 (iteration 0);
 * 						Thread 0 works on arrays partitions [4] [3]
 * 						Thread 1 works on arrays partitions [2] [1]
 *
 * 						Result stored in "res" array:
 * 						[3, 4, 1, 2, 0];
 *
 * 					For r = 4 (iteration 1)
 * 						Thread 0 works on arrays partitions [3, 4] [1, 2]
 *
 *						Result stored in "res" array:
 * 						[1, 2, 3, 4, 0];
 *
 * 					for r = 8 (iteration 2)
 * 						Thread 0 works on arrays partitions [1, 2, 3, 4] [0]
 *
 *						Result stored in "res" array:
 * 						[0, 1, 2, 3, 4];	
 *
 * 					This kernel perform one step of the merge sort on chuncks of 1024 elements
 * 					by copying the elements to the shared memory and then copying the results
 * 					back to the global memory
 *
 * Arguments:       float * sums: The array of sums of vertices
 * 					float * res: The array to which the sorted sums array will be stored
 * 					int * ind: The array of indices of vertices
 * 					int * ind_res: The array to which the sorted indices array will be saved.
 *					const unsigned int length: The total length of the array
 *					const unsigned int r: Equals to 2 times of the length of sub-arrays which have to be sorted.
 *
 * Return Values:   None
*******************************************************************************/
__global__
void kernel_merge_sort(float * sums, float * res, const unsigned int length, const unsigned int r){

	__shared__ float sh_sums[1024];
	__shared__ float sh_res[1024];
	unsigned int idx = blockIdx.x * blockDim.x + threadIdx.x;
	const unsigned int numthrds = blockDim.x * gridDim.x;

	const int stride = r/2;

	int id = threadIdx.x;
	int t_len = min(1024, length - blockIdx.x * blockDim.x);

	while(idx < length){
		// copy to shared mem
		sh_sums[threadIdx.x] = sums[idx];

		__syncthreads();

		// perform a step of merge sort
		if(id%r == 0)
			dev_merge(sh_sums, sh_res, id, min(t_len, id + stride), min(t_len, id+r));

		__syncthreads();

		// copy result to global mem
		res[idx] = sh_res[threadIdx.x];
		
		__syncthreads();
		
		idx += numthrds;
	}
}

/*******************************************************************************
 * Function:        kernel_merge_chuncks
 *
 * Description:     This is a kernal which implements PARALLELED merging of sorted
 * 					arrays. 
 * 					The Algorithm 1 of following reference describes the 
 * 					parallel merging of sorted arrays:
 *
 * 					: http://www2.hawaii.edu/~nodari/teaching/f16/notes/notes10.pdf
 *
 * 					The above reference assumes that the arrays don't contain the
 * 					duplicate elements. In our situation, we are sorting the arrays
 * 					to remove the duplicate elements hence we cannot use the above
 * 					algorithm directly.
 *
 * 					We have come up with a new algorithm which is a modified version
 * 					of the above algorithm. Following is the description of the 
 * 					algorithm.
 *
 * 					Say we have two sorted arrays, arr1 and arr2 to be merged and
 * 					have duplicate elements. The result of merging arr1 and arr2 has 
 * 					to be put in arr_res array.
 *
 * 		Task	1.	For an element "i" in arr1 i.e. arr1[i], find the index of largest
 * 					number in arr2 which is smaller than arr1[i] i.e.
 *
 * 						LS_index = argmax_j (arr2[j] < arr1[i]).
 *
 * 					LS_index is the index of the largest number in arr2 such that 
 * 					arr2[LS_index] < arr1[i]. Now place the arr1[i] at position
 * 					i + LS_index + 1 in the array arr_res i.e.
 *
 * 						arr_res[i+LS_index+1] = arr1[i].
 *
 * 					Do the task 1 for every element of arr1.
 *
 * 		Task	2.	Now for an elemetn "i" i arr2 i.e. arr2[i], find the index of smallest
 * 					number in arr1 which is larger than arr2[o] i.e.
 *
 * 						SL_index = argmin_j (arr2[i] < arr1[j])
 *
 * 					SL_index is the index of smallest number in arr1 such that
 * 					arr2[i] < arr1[SL_index]. Now place the arr2[i] at position i + SL_index
 * 					in the array arr_res i.e.
 *
 * 						arr_res[i+SL_index] = arr2[2].
 *
 * 					Do the task 2 for every element of arr2.
 *
 * 					The above algorithm has been parallelized with each threads operating
 * 					at each element of the array. Let us say we have two arrays, each of size
 *					1024 elements, then total of 2048 threads are used to merge the two arrays.
 *
 * Arguments:       float * sums: The array of sums of vertices
 * 					float * res: The array to which the sorted sums array will be stored
 * 					int * ind: The array of indices of vertices
 * 					int * ind_res: The array to which the sorted indices array will be saved.
 *					const unsigned int length: The total length of the array
 *					const unsigned int r: Equals to 2 times of length of sub-arrays which have to be sorted.
 *
 * Return Values:   None
*******************************************************************************/
__global__
void kernel_merge_chuncks(float * sums, float * res, const unsigned int length, const unsigned int r){
	
	unsigned int idx = blockIdx.x * blockDim.x + threadIdx.x;
	const unsigned int numthrds = blockDim.x * gridDim.x;
	const int stride = r/2;
	
	int tmp_res[1];
	
	int k;
	int local_k;
	int arr_len;
	int arr_start;
	int arr_ind_L, arr_ind_HE, final_index;
	
	while(idx < length){
		k = idx % r;
		local_k = k%stride;
		arr_ind_L = idx - local_k + stride;    // arr2 
		arr_ind_HE = idx - local_k - stride;   // arr1 

		if(k < stride && arr_ind_L < length){
			// an arr 1 element
			arr_len = min(stride, length - arr_ind_L);
			arr_start = idx - local_k + 1;

			get_last_smallest(&sums[arr_ind_L], arr_len, sums[idx], tmp_res);

			final_index = local_k + tmp_res[0] + arr_start;

		}else if( k>=stride && 0 <= arr_ind_HE){
			// an arr 2 element
			arr_len = min(stride, length - arr_ind_HE);
			arr_start = idx - local_k - stride;

			get_first_greatest(&sums[arr_ind_HE], arr_len, sums[idx], tmp_res);
			
			final_index = local_k + tmp_res[0] + arr_start;
		}
		
		// now place the element
		res[final_index] = sums[idx];
		
		idx += numthrds;
	}

}

/*******************************************************************************
 * Function:        cudacall_fill_vertices
 *
 * Description:     This calls the optimized sorting algorithms till ceil(log2(length(vertices))).
 * 					Once the sorting is complete it calls the "cuda_remove_duplicates" function
 * 					to remove the duplicate vertices from the sorted.
 *
 * 					Note that we are not sorting the arrays of vertices obtained from the 
 * 					faces array with respect to the sum of their components, rather we are
 * 					sorting the "indices" arrays with respect to the sum of components of 
 * 					the vertices. Once the sorting is complete the array of vertices is
 * 					updated with respect to the sorted indices array.
 *
 * 					The above approach allow the faster access to global memory and allows us
 * 					to use shared memory as the size of the sorting arrays has decreased
 * 					considerably.
 *
 * 					The order the sequential implementation of this algorithm is: O(Log(n)^2)
 * 					The order the parallel implementation of this algorithm is: O(Log(n)^2/m)
 * 					where m: no. of parallel running processors
 *
 * 					Hence this method performs much better than "naive" implementation.
 *
 * Arguments:       int thread_num: The number of threads per block.
 *
 * Return Values:   None
*******************************************************************************/
void cudacall_fill_vertices(int thread_num) {
	
	unsigned int len = 3*faces_length;
	int n_blocks = min(65535, (len + thread_num  - 1) / thread_num);

	unsigned int l = ceil(log2(thread_num)), ind1;
	for(int i=0; i<l; i++){
		ind1 = i%2;
		ind2_sums = (i+1)%2;
		unsigned int r = pow(2, i+1);
		kernel_merge_sort<<<n_blocks, thread_num>>>(pointers_sums[ind1], pointers_sums[ind2_sums], len, r);

	}

	// now sort the chunks of 1024 floats
	l = ceil(log2(n_blocks));
	for(int i=0; i<l; i++){
		ind1 = (ind1+1)%2;
		ind2_sums = (ind2_sums+1)%2;
		unsigned int r = pow(2, i+1)*1024;
		kernel_merge_chuncks<<<n_blocks, thread_num>>>(pointers_sums[ind1], pointers_sums[ind2_sums], len, r);
	}
}


/*******************************************************************************
 * Function:        get_first_greatest
 *
 * Description:     This kernel finds the index of the smallest value in the array
 * 					which is greater than the value "a" passed to it i.e. it finds
 * 					the index first greatest number.
 *
 * 					Mathematically:
 *
 *  					ref_fg = argmin_j (a < arr2[j]).
 *
 * Arguments:       floar * arr: The array in which the first greatest is to be found
 * 					int len: The length of the array
 * 					float a: The value with respect to which the first greatest has 
 * 								to be found
 * 					int * res_fg: It is used to return the result
 *
 * Return Values:   None
*******************************************************************************/
__device__
void get_first_greatest(float * arr, int len, float a, int * res_fg){
	int first = 0, last = len - 1;
	while (first <= last)
	{
		int mid = (first + last) / 2;
		if (arr[mid] > a)
			last = mid - 1;
		else
			first = mid + 1;
	}
	res_fg[0] =  last + 1 == len ? len : last + 1;

}

/*******************************************************************************
 * Function:        get_last_smallest
 *
 * Description:     This kernel finds the index of the largest value in the array
 * 					which is smaller than the value "a" passed to it i.e. it finds
 * 					the index first greatest number.
 *
 * 					Mathematically:
 *
 *  					ref_ls = argmax_j (arr2[j] < a).
 *
 * Arguments:       floar * arr: The array in which the last smallest is to be found
 * 					int len: The length of the array
 * 					float a: The value with respect to which the last smallest has 
 * 								to be found
 * 					int * res_fg: It is used to return the result
 *
 * Return Values:   None
*******************************************************************************/
__device__
void get_last_smallest(float * arr, int len, float a, int * res_ls){
	int first = 0, last = len - 1;
	while (first <= last)
	{
		int mid = (first + last) / 2;
		if (arr[mid] >= a)
			last = mid - 1;
		else
			first = mid + 1;
	}
	res_ls[0] = first - 1 < 0 ? -1 : first - 1;
}